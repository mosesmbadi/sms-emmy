name: Deploy Monitoring Infrastructure

on:
  push:
    branches: [ deployment-to-aws ]
    paths:
      - 'monitoring/**'
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment environment'
        required: true
        default: 'production'
        type: choice
        options:
          - production
          - staging

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  deploy-monitoring:
    runs-on: ubuntu-latest
    environment: ${{ github.event.inputs.environment || 'production' }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ secrets.AWS_REGION }}

    - name: Get EC2 instance IPs
      id: get-ips
      run: |
        # Get monitoring server IP
        MONITORING_IP=$(aws ec2 describe-instances \
          --filters "Name=tag:Name,Values=sms-emmy-monitoring" "Name=instance-state-name,Values=running" \
          --query 'Reservations[0].Instances[0].PublicIpAddress' \
          --output text)
        
        # Get application server IP
        APP_IP=$(aws ec2 describe-instances \
          --filters "Name=tag:Name,Values=sms-emmy-app" "Name=instance-state-name,Values=running" \
          --query 'Reservations[0].Instances[0].PublicIpAddress' \
          --output text)
        
        echo "monitoring_ip=$MONITORING_IP" >> $GITHUB_OUTPUT
        echo "app_ip=$APP_IP" >> $GITHUB_OUTPUT

    - name: Prepare monitoring configuration
      run: |
        # Replace placeholder with actual application server IP
        sed -i "s/<app-ip>/${{ steps.get-ips.outputs.app_ip }}/g" monitoring/prometheus-production.yml
        
        # Copy production config as the main config
        cp monitoring/prometheus-production.yml monitoring/prometheus.yml

    - name: Copy monitoring files to server
      uses: appleboy/scp-action@v0.1.4
      with:
        host: ${{ steps.get-ips.outputs.monitoring_ip }}
        username: ubuntu
        key: ${{ secrets.EC2_SSH_PRIVATE_KEY }}
        source: "monitoring/"
        target: "/home/ubuntu/sms-emmy/"
        overwrite: true

    - name: Deploy monitoring stack
      uses: appleboy/ssh-action@v0.1.5
      with:
        host: ${{ steps.get-ips.outputs.monitoring_ip }}
        username: ubuntu
        key: ${{ secrets.EC2_SSH_PRIVATE_KEY }}
        script: |
          cd /home/ubuntu/sms-emmy/monitoring
          
          # Set environment variables
          export GRAFANA_ADMIN_PASSWORD="${{ secrets.GRAFANA_ADMIN_PASSWORD }}"
          
          # Create necessary directories
          mkdir -p {prometheus_data,grafana_data,alertmanager_data}
          
          # Show the updated Prometheus config
          echo "üìã Prometheus targets configured:"
          grep -A 2 "targets:" prometheus.yml || echo "Config file not found"
          
          # Pull latest images
          docker-compose pull
          
          # Deploy monitoring stack
          docker-compose up -d
          
          # Wait for services to be ready
          echo "Waiting for services to start..."
          sleep 30
          
          # Health checks
          for service in prometheus:9090 grafana:3000 alertmanager:9093; do
            name=$(echo $service | cut -d: -f1)
            port=$(echo $service | cut -d: -f2)
            
            echo "Checking $name health..."
            if timeout 60 bash -c "until curl -f http://localhost:$port/api/health || curl -f http://localhost:$port/; do sleep 2; done"; then
              echo "‚úÖ $name is healthy"
            else
              echo "‚ùå $name health check failed"
              docker-compose logs $name
            fi
          done
          
          echo "üöÄ Monitoring stack deployed successfully!"
          echo "üìä Grafana: http://${{ steps.get-ips.outputs.monitoring_ip }}:3000"
          echo "üìà Prometheus: http://${{ steps.get-ips.outputs.monitoring_ip }}:9090"
          echo "üö® Alertmanager: http://${{ steps.get-ips.outputs.monitoring_ip }}:9093"
          echo "üéØ Monitoring targets: ${{ steps.get-ips.outputs.app_ip }}:5000"

    - name: Configure monitoring targets
      uses: appleboy/ssh-action@v0.1.5
      with:
        host: ${{ steps.get-ips.outputs.monitoring_ip }}
        username: ubuntu
        key: ${{ secrets.EC2_SSH_PRIVATE_KEY }}
        script: |
          cd /home/ubuntu/sms-emmy/monitoring
          
          # Verify Prometheus can reach the application
          echo "üîç Testing connectivity to application server..."
          if timeout 10 curl -f http://${{ steps.get-ips.outputs.app_ip }}:5000/health; then
            echo "‚úÖ Application server is reachable"
          else
            echo "‚ö†Ô∏è Warning: Cannot reach application server at ${{ steps.get-ips.outputs.app_ip }}:5000"
          fi
          
          # Reload Prometheus configuration
          docker-compose exec -T prometheus kill -HUP 1 || echo "Prometheus reload scheduled"
          
          # Wait and check if targets are discovered
          sleep 10
          echo "üìä Prometheus targets status:"
          curl -s http://localhost:9090/api/v1/targets | jq '.data.activeTargets[] | {job: .labels.job, instance: .labels.instance, health: .health}' || echo "Could not fetch targets"

    - name: Slack notification
      if: always()
      uses: 8398a7/action-slack@v3
      with:
        status: ${{ job.status }}
        channel: '#deployments'
        text: |
          Monitoring Infrastructure Deployment: ${{ job.status }}
          Environment: ${{ github.event.inputs.environment || 'production' }}
          Grafana: http://${{ steps.get-ips.outputs.monitoring_ip }}:3000
          Prometheus: http://${{ steps.get-ips.outputs.monitoring_ip }}:9090
          Targets: ${{ steps.get-ips.outputs.app_ip }}:5000
      env:
        SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
